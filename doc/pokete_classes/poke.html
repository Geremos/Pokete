<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pokete_classes.poke API documentation</title>
<meta name="description" content="Contains the Poke class" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pokete_classes.poke</code></h1>
</header>
<section id="section-intro">
<p>Contains the Poke class</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Contains the Poke class&#34;&#34;&#34;

import math
import time
import logging
import random
import scrap_engine as se
import pokete_data as p_data
from pokete_general_use_fns import liner
from release import SPEED_OF_TIME
from .attack_actions import AttackActions
from .attack import Attack
from .health_bar import HealthBar
from .evomap import EvoMap
from .color import Color
from .moves import Moves
from .types import types
from .effects import effects
from .learnattack import LearnAttack
from .nature import PokeNature


class Poke:
    &#34;&#34;&#34;The Pokete class
    ARGS:
        poke: The Pokes generic name
        _xp: Initial xp
        _hp: Initial hp (&#39;SKIP&#39; sets to max hp)
        _attacks: List of attack names learned
        player: Bool whether or not the Poke belongs to the player
        shiny: Bool whether or not the Poke is shiny (is extra strong)&#34;&#34;&#34;

    def __init__(self, poke, _xp, _hp=&#34;SKIP&#34;, _ap=None, _attacks=None,
                 _effects=None, player=True, shiny=False, nature=None):
        self.nature = PokeNature.random() if nature is None \
                        else PokeNature.from_dict(nature)
        self.inf = p_data.pokes[poke]
        self.moves = Moves(self)
        # Attributes
        self.night_active = self.inf.get(&#34;night_active&#34;, None)
        self.enem = None
        self.oldhp = 0
        self.xp = _xp
        self.identifier = poke
        self.shiny = shiny
        self.atc = 0
        self.defense = 0
        self.initiative = 0
        self.hp = self.inf[&#34;hp&#34;]
        self.name = self.inf[&#34;name&#34;]
        self.miss_chance = self.inf[&#34;miss_chance&#34;]
        self.lose_xp = self.inf[&#34;lose_xp&#34;]
        self.evolve_poke = self.inf[&#34;evolve_poke&#34;]
        self.evolve_lvl = self.inf[&#34;evolve_lvl&#34;]
        self.types = [getattr(types, i) for i in self.inf[&#34;types&#34;]]
        self.type = self.types[0]
        self.effects = []
        if _attacks is not None:
            assert (len(_attacks) &lt;= 4), f&#34;A Pokete {poke} \
can&#39;t have more than 4 attacks!&#34;
        else:
            _attacks = self.inf[&#34;attacks&#34;][:4]
        self.attacks = [atc for atc in _attacks
                        if self.lvl() &gt;= p_data.attacks[atc][&#34;min_lvl&#34;]]
        if self.shiny:
            self.hp += 5
        self.attack_obs = [Attack(atc, str(i + 1))
                           for i, atc in enumerate(self.attacks)
                           if self.lvl() &gt;= p_data.attacks[atc][&#34;min_lvl&#34;]]
        self.set_player(player)
        # Backup vars
        self.full_hp = self.hp
        self.full_miss_chance = self.miss_chance
        # re-set hp
        if _hp != &#34;SKIP&#34;:
            self.hp = _hp
        # Labels
        self.hp_bar = HealthBar(self)
        self.hp_bar.make(self.hp)
        self.desc = se.Text(liner(self.inf[&#34;desc&#34;], se.screen_width - 34))
        self.ico = se.Box(4, 11)
        for ico in self.inf[&#34;ico&#34;]:
            esccode = (str.join(&#34;&#34;, [getattr(Color, i) for i in ico[&#34;esc&#34;]])
                       if ico[&#34;esc&#34;] is not None
                       else &#34;&#34;)
            self.ico.add_ob(se.Text(ico[&#34;txt&#34;], state=&#34;float&#34;,
                                    esccode=esccode,
                                    ignore=f&#39;{esccode} {Color.reset}&#39;), 0, 0)
        self.text_hp = se.Text(f&#34;HP:{self.hp}&#34;, state=&#34;float&#34;)
        self.text_lvl = se.Text(f&#34;Lvl:{self.lvl()}&#34;, state=&#34;float&#34;)
        self.text_name = se.Text(self.name,
                                 esccode=Color.underlined + (Color.yellow
                                                             if self.shiny
                                                             else &#34;&#34;),
                                 state=&#34;float&#34;)
        self.text_xp = se.Text(
            f&#34;XP:{self.xp - (self.lvl() ** 2 - 1)}/\
{((self.lvl() + 1) ** 2 - 1) - (self.lvl() ** 2 - 1)}&#34;,
            state=&#34;float&#34;)
        self.text_type = se.Text(self.type.name.capitalize(),
                                 state=&#34;float&#34;, esccode=self.type.color)
        self.tril = se.Object(&#34;&lt;&#34;, state=&#34;float&#34;)
        self.trir = se.Object(&#34;&gt;&#34;, state=&#34;float&#34;)
        self.pball_small = se.Object(&#34;o&#34;)
        self.set_vars()
        if _ap is not None:
            self.set_ap(_ap)
        if _effects is not None:
            for eff in _effects:
                self.effects.append(getattr(effects, eff)(self))

    def set_player(self, player):
        &#34;&#34;&#34;Sets the player attribute when the Pokete changes the owner
        ARGS:
            player: Bool whether or not the Poke new belongs to the player&#34;&#34;&#34;
        self.player = player
        self.affil = &#34;you&#34; if self.player else &#34;enemy&#34;
        self.ext_name = f&#39;{self.name}({self.affil})&#39;

    def set_vars(self):
        &#34;&#34;&#34;Updates/sets some vars&#34;&#34;&#34;
        for name in [&#34;atc&#34;, &#34;defense&#34;, &#34;initiative&#34;]:
            setattr(self, name, round((self.lvl() + self.inf[name]
                    + (2 if self.shiny else 0)) * self.nature.get_value(name)))
        for atc in self.attack_obs:
            atc.set_ap(atc.max_ap)

    def dict(self):
        &#34;&#34;&#34;RETURNS:
            A dict with all information about the Pokete&#34;&#34;&#34;
        return {&#34;name&#34;: self.identifier, &#34;xp&#34;: self.xp, &#34;hp&#34;: self.hp,
                &#34;ap&#34;: [atc.ap for atc in self.attack_obs],
                &#34;effects&#34;: [eff.c_name for eff in self.effects],
                &#34;attacks&#34;: self.attacks,
                &#34;shiny&#34;: self.shiny,
                &#34;nature&#34;: self.nature.dict()}

    def set_ap(self, aps):
        &#34;&#34;&#34;Sets attack aps from a list
        ARGS:
            aps: List of attack ap&#34;&#34;&#34;
        for atc, ap in zip(self.attack_obs, aps):
            atc.set_ap(ap)

    def add_xp(self, _xp):
        &#34;&#34;&#34;Adds xp to the current pokete
        ARGS:
            _xp: Amount of xp added to the current xp
        RETURNS:
            bool: whether or not the next level is reached&#34;&#34;&#34;
        old_lvl = self.lvl()
        self.xp += _xp
        self.text_xp.rechar(f&#34;XP:{self.xp - (self.lvl() ** 2 - 1)}/\
{((self.lvl() + 1) ** 2 - 1) - (self.lvl() ** 2 - 1)}&#34;)
        self.text_lvl.rechar(f&#34;Lvl:{self.lvl()}&#34;)
        logging.info(&#34;[Poke][%s] Gained %dxp (curr:%d)&#34;, self.name, _xp, self.xp)
        if old_lvl &lt; self.lvl():
            logging.info(&#34;[Poke][%s] Reached lvl. %d&#34;, self.name, self.lvl())
            return True
        return False

    def lvl(self):
        &#34;&#34;&#34;RETURNS:
            Current level&#34;&#34;&#34;
        return int(math.sqrt(self.xp + 1))

    def attack(self, attack, enem, fightmap, providers):
        &#34;&#34;&#34;Attack process
        ARGS:
            attack: Attack object
            enem: Enemy Poke
            fightmap: The map object where the fight is carried out on.&#34;&#34;&#34;
        weather = providers[0].map.weather
        if attack.ap &gt; 0:
            for eff in self.effects:
                eff.remove()
            for eff in self.effects:
                if eff.effect() == 1:
                    return
            if any(isinstance(i, effects.confusion) for i in self.effects):
                self.enem = enem = self
            else:
                self.enem = enem
            w_eff = 1
            random_factor = random.choices([0, 0.75, 1, 1.26],
                                           weights=[attack.miss_chance
                                                    + self.miss_chance,
                                                    1, 1, 1], k=1)[0]
            if weather is not None:
                w_eff = weather.effect(attack.type)
                fightmap.outp.outp(weather.info)
                time.sleep(SPEED_OF_TIME * 1.5)
            enem.oldhp = enem.hp
            self.oldhp = self.hp
            eff = (1.3 if enem.type.name in attack.type.effective else 0.5
                   if enem.type.name in attack.type.ineffective else 1) * w_eff
            n_hp = round((self.atc
                          * attack.factor
                          / (enem.defense if enem.defense &gt;= 1 else 1))
                         * random_factor * eff)
            eff_text = {
                eff &lt; 1: &#34;\nThat was not effective! &#34;,
                eff &gt; 1: &#34;\nThat was very effective! &#34;,
                eff == 1 or n_hp == 0: &#34;&#34;,
                random_factor == 0: f&#34;{self.name} missed!&#34;}[True]
            enem.hp -= max(n_hp, 0)
            enem.hp = max(enem.hp, 0)
            time.sleep(SPEED_OF_TIME * 0.4)
            for i in attack.move:
                getattr(self.moves, i)()
            if attack.action is not None and random_factor != 0:
                getattr(AttackActions(), attack.action)(self, enem, providers)
            attack.set_ap(attack.ap - 1)
            fightmap.outp.outp(
                f&#39;{self.ext_name} used {attack.name}! {eff_text}&#39;)
            if enem == self:
                time.sleep(SPEED_OF_TIME * 1)
                fightmap.outp.outp(f&#39;{self.ext_name} hurt itself!&#39;)
            if random_factor != 0:
                attack.give_effect(enem)
            for obj in [enem, self] if enem != self else [enem]:
                obj.hp_bar.update(obj.oldhp)
            logging.info(&#34;[Poke][%s] Used %s: %s&#34;, self.name, attack.name,
                         str({&#34;eff&#34;: eff, &#34;n_hp&#34;: n_hp}))
            fightmap.show()

    def learn_attack(self, _map):
        &#34;&#34;&#34;Checks if a new attack can be learned and then teaches it the poke
        ARGS:
            _map: The map this happens on&#34;&#34;&#34;
        if self.lvl() % 5 == 0:
            LearnAttack(self, _map)()

    def evolve(self, figure, _map):
        &#34;&#34;&#34;Evolves the Pokete to its evolve_poke
        ARGS:
            figure: The figure object the poke belongs to
            _map: The map the evolving happens on&#34;&#34;&#34;
        if not self.player or self.evolve_poke == &#34;&#34; \
                or self.lvl() &lt; self.evolve_lvl:
            return False
        evomap = EvoMap(_map.height, _map.width)
        new = Poke(self.evolve_poke, self.xp, _attacks=self.attacks, shiny=self.shiny)
        self.ico.remove()
        self.ico.add(evomap, round(evomap.width / 2 - 4),
                     round((evomap.height - 8) / 2))
        self.moves.shine()
        evomap.outp.outp(&#34;Look!&#34;)
        time.sleep(SPEED_OF_TIME * 0.5)
        evomap.outp.outp(f&#34;{evomap.outp.text}\n{self.name} is evolving!&#34;)
        time.sleep(SPEED_OF_TIME * 1)
        for i in range(8):
            for j, k in zip([self.ico, new.ico], [new.ico, self.ico]):
                j.remove()
                k.add(evomap, round(evomap.width / 2 - 4),
                      round((evomap.height - 8) / 2))
                time.sleep(SPEED_OF_TIME * 0.7 - i * 0.09999)
                evomap.show()
        self.ico.remove()
        new.ico.add(evomap, round(evomap.width / 2 - 4),
                    round((evomap.height - 8) / 2))
        evomap.show()
        time.sleep(SPEED_OF_TIME * 0.01)
        new.moves.shine()
        evomap.outp.outp(f&#34;{self.name} evolved into {new.name}!&#34;)
        time.sleep(SPEED_OF_TIME * 5)
        for i in range(max(len(p_data.pokes[new.identifier][&#34;attacks&#34;])
                           - len(self.attack_obs), 0)):
            LearnAttack(new, evomap)()
        figure.pokes[figure.pokes.index(self)] = new
        if new.identifier not in figure.caught_pokes:
            figure.caught_pokes.append(new.identifier)
        logging.info(&#34;[Poke] %s evolved into %s&#34;, self.name, new.name)
        del self
        return True

    @classmethod
    def from_dict(cls, _dict):
        &#34;&#34;&#34;Assembles a Pokete from _dict&#34;&#34;&#34;
        return cls(_dict[&#34;name&#34;], _dict[&#34;xp&#34;], _dict[&#34;hp&#34;], _dict[&#34;ap&#34;],
                   _dict.get(&#34;attacks&#34;, None), _dict.get(&#34;effects&#34;, []),
                   shiny=_dict.get(&#34;shiny&#34;, False), nature=_dict.get(&#34;nature&#34;))

    @classmethod
    def wild(cls, poke, _xp):
        &#34;&#34;&#34;Simulates learning attacks for wild poketes
        ARGS:
            poke: The poketes descriptor
            _xp: The poketes given xp&#34;&#34;&#34;
        obj = cls(poke, _xp)
        for i in range(obj.lvl()):
            if (
                i % 5 == 0
                and (new_attack := LearnAttack.get_attack(obj)) is not None
            ):
                obj.attacks.append(new_attack)

        while len(obj.attacks) &gt; 4:
            obj.attacks.pop(random.randint(0, len(obj.attacks)-1))

        return cls(
            poke,
            _xp,
            _attacks=obj.attacks,
            player=False,
            shiny=(random.randint(0, 500) == 0)
        )


def upgrade_by_one_lvl(poke, figure, _map):
    &#34;&#34;&#34;Upgrades a Pokete by exactly one level, this will only be used by treats
    ARGS:
        poke: The pokete, that will be upgraded
        figure: The figure object the Pokete belongs to
        _map: The map the upgrade happens on&#34;&#34;&#34;
    poke.add_xp((poke.lvl()+1)**2-1 - ((poke.lvl())**2-1))
    poke.set_vars()
    poke.learn_attack(_map)
    poke.evolve(figure, _map)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pokete_classes.poke.upgrade_by_one_lvl"><code class="name flex">
<span>def <span class="ident">upgrade_by_one_lvl</span></span>(<span>poke, figure, _map)</span>
</code></dt>
<dd>
<div class="desc"><p>Upgrades a Pokete by exactly one level, this will only be used by treats</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poke</code></strong></dt>
<dd>The pokete, that will be upgraded</dd>
<dt><strong><code>figure</code></strong></dt>
<dd>The figure object the Pokete belongs to</dd>
<dt><strong><code>_map</code></strong></dt>
<dd>The map the upgrade happens on</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upgrade_by_one_lvl(poke, figure, _map):
    &#34;&#34;&#34;Upgrades a Pokete by exactly one level, this will only be used by treats
    ARGS:
        poke: The pokete, that will be upgraded
        figure: The figure object the Pokete belongs to
        _map: The map the upgrade happens on&#34;&#34;&#34;
    poke.add_xp((poke.lvl()+1)**2-1 - ((poke.lvl())**2-1))
    poke.set_vars()
    poke.learn_attack(_map)
    poke.evolve(figure, _map)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pokete_classes.poke.Poke"><code class="flex name class">
<span>class <span class="ident">Poke</span></span>
<span>(</span><span>poke, _xp, player=True, shiny=False, nature=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Pokete class</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poke</code></strong></dt>
<dd>The Pokes generic name</dd>
<dt><strong><code>_xp</code></strong></dt>
<dd>Initial xp</dd>
<dt><strong><code>_hp</code></strong></dt>
<dd>Initial hp ('SKIP' sets to max hp)</dd>
<dt><strong><code>_attacks</code></strong></dt>
<dd>List of attack names learned</dd>
<dt><strong><code>player</code></strong></dt>
<dd>Bool whether or not the Poke belongs to the player</dd>
<dt><strong><code>shiny</code></strong></dt>
<dd>Bool whether or not the Poke is shiny (is extra strong)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Poke:
    &#34;&#34;&#34;The Pokete class
    ARGS:
        poke: The Pokes generic name
        _xp: Initial xp
        _hp: Initial hp (&#39;SKIP&#39; sets to max hp)
        _attacks: List of attack names learned
        player: Bool whether or not the Poke belongs to the player
        shiny: Bool whether or not the Poke is shiny (is extra strong)&#34;&#34;&#34;

    def __init__(self, poke, _xp, _hp=&#34;SKIP&#34;, _ap=None, _attacks=None,
                 _effects=None, player=True, shiny=False, nature=None):
        self.nature = PokeNature.random() if nature is None \
                        else PokeNature.from_dict(nature)
        self.inf = p_data.pokes[poke]
        self.moves = Moves(self)
        # Attributes
        self.night_active = self.inf.get(&#34;night_active&#34;, None)
        self.enem = None
        self.oldhp = 0
        self.xp = _xp
        self.identifier = poke
        self.shiny = shiny
        self.atc = 0
        self.defense = 0
        self.initiative = 0
        self.hp = self.inf[&#34;hp&#34;]
        self.name = self.inf[&#34;name&#34;]
        self.miss_chance = self.inf[&#34;miss_chance&#34;]
        self.lose_xp = self.inf[&#34;lose_xp&#34;]
        self.evolve_poke = self.inf[&#34;evolve_poke&#34;]
        self.evolve_lvl = self.inf[&#34;evolve_lvl&#34;]
        self.types = [getattr(types, i) for i in self.inf[&#34;types&#34;]]
        self.type = self.types[0]
        self.effects = []
        if _attacks is not None:
            assert (len(_attacks) &lt;= 4), f&#34;A Pokete {poke} \
can&#39;t have more than 4 attacks!&#34;
        else:
            _attacks = self.inf[&#34;attacks&#34;][:4]
        self.attacks = [atc for atc in _attacks
                        if self.lvl() &gt;= p_data.attacks[atc][&#34;min_lvl&#34;]]
        if self.shiny:
            self.hp += 5
        self.attack_obs = [Attack(atc, str(i + 1))
                           for i, atc in enumerate(self.attacks)
                           if self.lvl() &gt;= p_data.attacks[atc][&#34;min_lvl&#34;]]
        self.set_player(player)
        # Backup vars
        self.full_hp = self.hp
        self.full_miss_chance = self.miss_chance
        # re-set hp
        if _hp != &#34;SKIP&#34;:
            self.hp = _hp
        # Labels
        self.hp_bar = HealthBar(self)
        self.hp_bar.make(self.hp)
        self.desc = se.Text(liner(self.inf[&#34;desc&#34;], se.screen_width - 34))
        self.ico = se.Box(4, 11)
        for ico in self.inf[&#34;ico&#34;]:
            esccode = (str.join(&#34;&#34;, [getattr(Color, i) for i in ico[&#34;esc&#34;]])
                       if ico[&#34;esc&#34;] is not None
                       else &#34;&#34;)
            self.ico.add_ob(se.Text(ico[&#34;txt&#34;], state=&#34;float&#34;,
                                    esccode=esccode,
                                    ignore=f&#39;{esccode} {Color.reset}&#39;), 0, 0)
        self.text_hp = se.Text(f&#34;HP:{self.hp}&#34;, state=&#34;float&#34;)
        self.text_lvl = se.Text(f&#34;Lvl:{self.lvl()}&#34;, state=&#34;float&#34;)
        self.text_name = se.Text(self.name,
                                 esccode=Color.underlined + (Color.yellow
                                                             if self.shiny
                                                             else &#34;&#34;),
                                 state=&#34;float&#34;)
        self.text_xp = se.Text(
            f&#34;XP:{self.xp - (self.lvl() ** 2 - 1)}/\
{((self.lvl() + 1) ** 2 - 1) - (self.lvl() ** 2 - 1)}&#34;,
            state=&#34;float&#34;)
        self.text_type = se.Text(self.type.name.capitalize(),
                                 state=&#34;float&#34;, esccode=self.type.color)
        self.tril = se.Object(&#34;&lt;&#34;, state=&#34;float&#34;)
        self.trir = se.Object(&#34;&gt;&#34;, state=&#34;float&#34;)
        self.pball_small = se.Object(&#34;o&#34;)
        self.set_vars()
        if _ap is not None:
            self.set_ap(_ap)
        if _effects is not None:
            for eff in _effects:
                self.effects.append(getattr(effects, eff)(self))

    def set_player(self, player):
        &#34;&#34;&#34;Sets the player attribute when the Pokete changes the owner
        ARGS:
            player: Bool whether or not the Poke new belongs to the player&#34;&#34;&#34;
        self.player = player
        self.affil = &#34;you&#34; if self.player else &#34;enemy&#34;
        self.ext_name = f&#39;{self.name}({self.affil})&#39;

    def set_vars(self):
        &#34;&#34;&#34;Updates/sets some vars&#34;&#34;&#34;
        for name in [&#34;atc&#34;, &#34;defense&#34;, &#34;initiative&#34;]:
            setattr(self, name, round((self.lvl() + self.inf[name]
                    + (2 if self.shiny else 0)) * self.nature.get_value(name)))
        for atc in self.attack_obs:
            atc.set_ap(atc.max_ap)

    def dict(self):
        &#34;&#34;&#34;RETURNS:
            A dict with all information about the Pokete&#34;&#34;&#34;
        return {&#34;name&#34;: self.identifier, &#34;xp&#34;: self.xp, &#34;hp&#34;: self.hp,
                &#34;ap&#34;: [atc.ap for atc in self.attack_obs],
                &#34;effects&#34;: [eff.c_name for eff in self.effects],
                &#34;attacks&#34;: self.attacks,
                &#34;shiny&#34;: self.shiny,
                &#34;nature&#34;: self.nature.dict()}

    def set_ap(self, aps):
        &#34;&#34;&#34;Sets attack aps from a list
        ARGS:
            aps: List of attack ap&#34;&#34;&#34;
        for atc, ap in zip(self.attack_obs, aps):
            atc.set_ap(ap)

    def add_xp(self, _xp):
        &#34;&#34;&#34;Adds xp to the current pokete
        ARGS:
            _xp: Amount of xp added to the current xp
        RETURNS:
            bool: whether or not the next level is reached&#34;&#34;&#34;
        old_lvl = self.lvl()
        self.xp += _xp
        self.text_xp.rechar(f&#34;XP:{self.xp - (self.lvl() ** 2 - 1)}/\
{((self.lvl() + 1) ** 2 - 1) - (self.lvl() ** 2 - 1)}&#34;)
        self.text_lvl.rechar(f&#34;Lvl:{self.lvl()}&#34;)
        logging.info(&#34;[Poke][%s] Gained %dxp (curr:%d)&#34;, self.name, _xp, self.xp)
        if old_lvl &lt; self.lvl():
            logging.info(&#34;[Poke][%s] Reached lvl. %d&#34;, self.name, self.lvl())
            return True
        return False

    def lvl(self):
        &#34;&#34;&#34;RETURNS:
            Current level&#34;&#34;&#34;
        return int(math.sqrt(self.xp + 1))

    def attack(self, attack, enem, fightmap, providers):
        &#34;&#34;&#34;Attack process
        ARGS:
            attack: Attack object
            enem: Enemy Poke
            fightmap: The map object where the fight is carried out on.&#34;&#34;&#34;
        weather = providers[0].map.weather
        if attack.ap &gt; 0:
            for eff in self.effects:
                eff.remove()
            for eff in self.effects:
                if eff.effect() == 1:
                    return
            if any(isinstance(i, effects.confusion) for i in self.effects):
                self.enem = enem = self
            else:
                self.enem = enem
            w_eff = 1
            random_factor = random.choices([0, 0.75, 1, 1.26],
                                           weights=[attack.miss_chance
                                                    + self.miss_chance,
                                                    1, 1, 1], k=1)[0]
            if weather is not None:
                w_eff = weather.effect(attack.type)
                fightmap.outp.outp(weather.info)
                time.sleep(SPEED_OF_TIME * 1.5)
            enem.oldhp = enem.hp
            self.oldhp = self.hp
            eff = (1.3 if enem.type.name in attack.type.effective else 0.5
                   if enem.type.name in attack.type.ineffective else 1) * w_eff
            n_hp = round((self.atc
                          * attack.factor
                          / (enem.defense if enem.defense &gt;= 1 else 1))
                         * random_factor * eff)
            eff_text = {
                eff &lt; 1: &#34;\nThat was not effective! &#34;,
                eff &gt; 1: &#34;\nThat was very effective! &#34;,
                eff == 1 or n_hp == 0: &#34;&#34;,
                random_factor == 0: f&#34;{self.name} missed!&#34;}[True]
            enem.hp -= max(n_hp, 0)
            enem.hp = max(enem.hp, 0)
            time.sleep(SPEED_OF_TIME * 0.4)
            for i in attack.move:
                getattr(self.moves, i)()
            if attack.action is not None and random_factor != 0:
                getattr(AttackActions(), attack.action)(self, enem, providers)
            attack.set_ap(attack.ap - 1)
            fightmap.outp.outp(
                f&#39;{self.ext_name} used {attack.name}! {eff_text}&#39;)
            if enem == self:
                time.sleep(SPEED_OF_TIME * 1)
                fightmap.outp.outp(f&#39;{self.ext_name} hurt itself!&#39;)
            if random_factor != 0:
                attack.give_effect(enem)
            for obj in [enem, self] if enem != self else [enem]:
                obj.hp_bar.update(obj.oldhp)
            logging.info(&#34;[Poke][%s] Used %s: %s&#34;, self.name, attack.name,
                         str({&#34;eff&#34;: eff, &#34;n_hp&#34;: n_hp}))
            fightmap.show()

    def learn_attack(self, _map):
        &#34;&#34;&#34;Checks if a new attack can be learned and then teaches it the poke
        ARGS:
            _map: The map this happens on&#34;&#34;&#34;
        if self.lvl() % 5 == 0:
            LearnAttack(self, _map)()

    def evolve(self, figure, _map):
        &#34;&#34;&#34;Evolves the Pokete to its evolve_poke
        ARGS:
            figure: The figure object the poke belongs to
            _map: The map the evolving happens on&#34;&#34;&#34;
        if not self.player or self.evolve_poke == &#34;&#34; \
                or self.lvl() &lt; self.evolve_lvl:
            return False
        evomap = EvoMap(_map.height, _map.width)
        new = Poke(self.evolve_poke, self.xp, _attacks=self.attacks, shiny=self.shiny)
        self.ico.remove()
        self.ico.add(evomap, round(evomap.width / 2 - 4),
                     round((evomap.height - 8) / 2))
        self.moves.shine()
        evomap.outp.outp(&#34;Look!&#34;)
        time.sleep(SPEED_OF_TIME * 0.5)
        evomap.outp.outp(f&#34;{evomap.outp.text}\n{self.name} is evolving!&#34;)
        time.sleep(SPEED_OF_TIME * 1)
        for i in range(8):
            for j, k in zip([self.ico, new.ico], [new.ico, self.ico]):
                j.remove()
                k.add(evomap, round(evomap.width / 2 - 4),
                      round((evomap.height - 8) / 2))
                time.sleep(SPEED_OF_TIME * 0.7 - i * 0.09999)
                evomap.show()
        self.ico.remove()
        new.ico.add(evomap, round(evomap.width / 2 - 4),
                    round((evomap.height - 8) / 2))
        evomap.show()
        time.sleep(SPEED_OF_TIME * 0.01)
        new.moves.shine()
        evomap.outp.outp(f&#34;{self.name} evolved into {new.name}!&#34;)
        time.sleep(SPEED_OF_TIME * 5)
        for i in range(max(len(p_data.pokes[new.identifier][&#34;attacks&#34;])
                           - len(self.attack_obs), 0)):
            LearnAttack(new, evomap)()
        figure.pokes[figure.pokes.index(self)] = new
        if new.identifier not in figure.caught_pokes:
            figure.caught_pokes.append(new.identifier)
        logging.info(&#34;[Poke] %s evolved into %s&#34;, self.name, new.name)
        del self
        return True

    @classmethod
    def from_dict(cls, _dict):
        &#34;&#34;&#34;Assembles a Pokete from _dict&#34;&#34;&#34;
        return cls(_dict[&#34;name&#34;], _dict[&#34;xp&#34;], _dict[&#34;hp&#34;], _dict[&#34;ap&#34;],
                   _dict.get(&#34;attacks&#34;, None), _dict.get(&#34;effects&#34;, []),
                   shiny=_dict.get(&#34;shiny&#34;, False), nature=_dict.get(&#34;nature&#34;))

    @classmethod
    def wild(cls, poke, _xp):
        &#34;&#34;&#34;Simulates learning attacks for wild poketes
        ARGS:
            poke: The poketes descriptor
            _xp: The poketes given xp&#34;&#34;&#34;
        obj = cls(poke, _xp)
        for i in range(obj.lvl()):
            if (
                i % 5 == 0
                and (new_attack := LearnAttack.get_attack(obj)) is not None
            ):
                obj.attacks.append(new_attack)

        while len(obj.attacks) &gt; 4:
            obj.attacks.pop(random.randint(0, len(obj.attacks)-1))

        return cls(
            poke,
            _xp,
            _attacks=obj.attacks,
            player=False,
            shiny=(random.randint(0, 500) == 0)
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pokete_classes.poke.Poke.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>_dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Assembles a Pokete from _dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls, _dict):
    &#34;&#34;&#34;Assembles a Pokete from _dict&#34;&#34;&#34;
    return cls(_dict[&#34;name&#34;], _dict[&#34;xp&#34;], _dict[&#34;hp&#34;], _dict[&#34;ap&#34;],
               _dict.get(&#34;attacks&#34;, None), _dict.get(&#34;effects&#34;, []),
               shiny=_dict.get(&#34;shiny&#34;, False), nature=_dict.get(&#34;nature&#34;))</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.wild"><code class="name flex">
<span>def <span class="ident">wild</span></span>(<span>poke, _xp)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates learning attacks for wild poketes</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>poke</code></strong></dt>
<dd>The poketes descriptor</dd>
<dt><strong><code>_xp</code></strong></dt>
<dd>The poketes given xp</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def wild(cls, poke, _xp):
    &#34;&#34;&#34;Simulates learning attacks for wild poketes
    ARGS:
        poke: The poketes descriptor
        _xp: The poketes given xp&#34;&#34;&#34;
    obj = cls(poke, _xp)
    for i in range(obj.lvl()):
        if (
            i % 5 == 0
            and (new_attack := LearnAttack.get_attack(obj)) is not None
        ):
            obj.attacks.append(new_attack)

    while len(obj.attacks) &gt; 4:
        obj.attacks.pop(random.randint(0, len(obj.attacks)-1))

    return cls(
        poke,
        _xp,
        _attacks=obj.attacks,
        player=False,
        shiny=(random.randint(0, 500) == 0)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pokete_classes.poke.Poke.add_xp"><code class="name flex">
<span>def <span class="ident">add_xp</span></span>(<span>self, _xp)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds xp to the current pokete</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_xp</code></strong></dt>
<dd>Amount of xp added to the current xp</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>whether or not the next level is reached</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def add_xp(self, _xp):
        &#34;&#34;&#34;Adds xp to the current pokete
        ARGS:
            _xp: Amount of xp added to the current xp
        RETURNS:
            bool: whether or not the next level is reached&#34;&#34;&#34;
        old_lvl = self.lvl()
        self.xp += _xp
        self.text_xp.rechar(f&#34;XP:{self.xp - (self.lvl() ** 2 - 1)}/\
{((self.lvl() + 1) ** 2 - 1) - (self.lvl() ** 2 - 1)}&#34;)
        self.text_lvl.rechar(f&#34;Lvl:{self.lvl()}&#34;)
        logging.info(&#34;[Poke][%s] Gained %dxp (curr:%d)&#34;, self.name, _xp, self.xp)
        if old_lvl &lt; self.lvl():
            logging.info(&#34;[Poke][%s] Reached lvl. %d&#34;, self.name, self.lvl())
            return True
        return False</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.attack"><code class="name flex">
<span>def <span class="ident">attack</span></span>(<span>self, attack, enem, fightmap, providers)</span>
</code></dt>
<dd>
<div class="desc"><p>Attack process</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attack</code></strong></dt>
<dd>Attack object</dd>
<dt><strong><code>enem</code></strong></dt>
<dd>Enemy Poke</dd>
<dt><strong><code>fightmap</code></strong></dt>
<dd>The map object where the fight is carried out on.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attack(self, attack, enem, fightmap, providers):
    &#34;&#34;&#34;Attack process
    ARGS:
        attack: Attack object
        enem: Enemy Poke
        fightmap: The map object where the fight is carried out on.&#34;&#34;&#34;
    weather = providers[0].map.weather
    if attack.ap &gt; 0:
        for eff in self.effects:
            eff.remove()
        for eff in self.effects:
            if eff.effect() == 1:
                return
        if any(isinstance(i, effects.confusion) for i in self.effects):
            self.enem = enem = self
        else:
            self.enem = enem
        w_eff = 1
        random_factor = random.choices([0, 0.75, 1, 1.26],
                                       weights=[attack.miss_chance
                                                + self.miss_chance,
                                                1, 1, 1], k=1)[0]
        if weather is not None:
            w_eff = weather.effect(attack.type)
            fightmap.outp.outp(weather.info)
            time.sleep(SPEED_OF_TIME * 1.5)
        enem.oldhp = enem.hp
        self.oldhp = self.hp
        eff = (1.3 if enem.type.name in attack.type.effective else 0.5
               if enem.type.name in attack.type.ineffective else 1) * w_eff
        n_hp = round((self.atc
                      * attack.factor
                      / (enem.defense if enem.defense &gt;= 1 else 1))
                     * random_factor * eff)
        eff_text = {
            eff &lt; 1: &#34;\nThat was not effective! &#34;,
            eff &gt; 1: &#34;\nThat was very effective! &#34;,
            eff == 1 or n_hp == 0: &#34;&#34;,
            random_factor == 0: f&#34;{self.name} missed!&#34;}[True]
        enem.hp -= max(n_hp, 0)
        enem.hp = max(enem.hp, 0)
        time.sleep(SPEED_OF_TIME * 0.4)
        for i in attack.move:
            getattr(self.moves, i)()
        if attack.action is not None and random_factor != 0:
            getattr(AttackActions(), attack.action)(self, enem, providers)
        attack.set_ap(attack.ap - 1)
        fightmap.outp.outp(
            f&#39;{self.ext_name} used {attack.name}! {eff_text}&#39;)
        if enem == self:
            time.sleep(SPEED_OF_TIME * 1)
            fightmap.outp.outp(f&#39;{self.ext_name} hurt itself!&#39;)
        if random_factor != 0:
            attack.give_effect(enem)
        for obj in [enem, self] if enem != self else [enem]:
            obj.hp_bar.update(obj.oldhp)
        logging.info(&#34;[Poke][%s] Used %s: %s&#34;, self.name, attack.name,
                     str({&#34;eff&#34;: eff, &#34;n_hp&#34;: n_hp}))
        fightmap.show()</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>RETURNS:
A dict with all information about the Pokete</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict(self):
    &#34;&#34;&#34;RETURNS:
        A dict with all information about the Pokete&#34;&#34;&#34;
    return {&#34;name&#34;: self.identifier, &#34;xp&#34;: self.xp, &#34;hp&#34;: self.hp,
            &#34;ap&#34;: [atc.ap for atc in self.attack_obs],
            &#34;effects&#34;: [eff.c_name for eff in self.effects],
            &#34;attacks&#34;: self.attacks,
            &#34;shiny&#34;: self.shiny,
            &#34;nature&#34;: self.nature.dict()}</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.evolve"><code class="name flex">
<span>def <span class="ident">evolve</span></span>(<span>self, figure, _map)</span>
</code></dt>
<dd>
<div class="desc"><p>Evolves the Pokete to its evolve_poke</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>figure</code></strong></dt>
<dd>The figure object the poke belongs to</dd>
<dt><strong><code>_map</code></strong></dt>
<dd>The map the evolving happens on</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evolve(self, figure, _map):
    &#34;&#34;&#34;Evolves the Pokete to its evolve_poke
    ARGS:
        figure: The figure object the poke belongs to
        _map: The map the evolving happens on&#34;&#34;&#34;
    if not self.player or self.evolve_poke == &#34;&#34; \
            or self.lvl() &lt; self.evolve_lvl:
        return False
    evomap = EvoMap(_map.height, _map.width)
    new = Poke(self.evolve_poke, self.xp, _attacks=self.attacks, shiny=self.shiny)
    self.ico.remove()
    self.ico.add(evomap, round(evomap.width / 2 - 4),
                 round((evomap.height - 8) / 2))
    self.moves.shine()
    evomap.outp.outp(&#34;Look!&#34;)
    time.sleep(SPEED_OF_TIME * 0.5)
    evomap.outp.outp(f&#34;{evomap.outp.text}\n{self.name} is evolving!&#34;)
    time.sleep(SPEED_OF_TIME * 1)
    for i in range(8):
        for j, k in zip([self.ico, new.ico], [new.ico, self.ico]):
            j.remove()
            k.add(evomap, round(evomap.width / 2 - 4),
                  round((evomap.height - 8) / 2))
            time.sleep(SPEED_OF_TIME * 0.7 - i * 0.09999)
            evomap.show()
    self.ico.remove()
    new.ico.add(evomap, round(evomap.width / 2 - 4),
                round((evomap.height - 8) / 2))
    evomap.show()
    time.sleep(SPEED_OF_TIME * 0.01)
    new.moves.shine()
    evomap.outp.outp(f&#34;{self.name} evolved into {new.name}!&#34;)
    time.sleep(SPEED_OF_TIME * 5)
    for i in range(max(len(p_data.pokes[new.identifier][&#34;attacks&#34;])
                       - len(self.attack_obs), 0)):
        LearnAttack(new, evomap)()
    figure.pokes[figure.pokes.index(self)] = new
    if new.identifier not in figure.caught_pokes:
        figure.caught_pokes.append(new.identifier)
    logging.info(&#34;[Poke] %s evolved into %s&#34;, self.name, new.name)
    del self
    return True</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.learn_attack"><code class="name flex">
<span>def <span class="ident">learn_attack</span></span>(<span>self, _map)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a new attack can be learned and then teaches it the poke</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_map</code></strong></dt>
<dd>The map this happens on</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def learn_attack(self, _map):
    &#34;&#34;&#34;Checks if a new attack can be learned and then teaches it the poke
    ARGS:
        _map: The map this happens on&#34;&#34;&#34;
    if self.lvl() % 5 == 0:
        LearnAttack(self, _map)()</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.lvl"><code class="name flex">
<span>def <span class="ident">lvl</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>RETURNS:
Current level</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lvl(self):
    &#34;&#34;&#34;RETURNS:
        Current level&#34;&#34;&#34;
    return int(math.sqrt(self.xp + 1))</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.set_ap"><code class="name flex">
<span>def <span class="ident">set_ap</span></span>(<span>self, aps)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets attack aps from a list</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>aps</code></strong></dt>
<dd>List of attack ap</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ap(self, aps):
    &#34;&#34;&#34;Sets attack aps from a list
    ARGS:
        aps: List of attack ap&#34;&#34;&#34;
    for atc, ap in zip(self.attack_obs, aps):
        atc.set_ap(ap)</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.set_player"><code class="name flex">
<span>def <span class="ident">set_player</span></span>(<span>self, player)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the player attribute when the Pokete changes the owner</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>player</code></strong></dt>
<dd>Bool whether or not the Poke new belongs to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_player(self, player):
    &#34;&#34;&#34;Sets the player attribute when the Pokete changes the owner
    ARGS:
        player: Bool whether or not the Poke new belongs to the player&#34;&#34;&#34;
    self.player = player
    self.affil = &#34;you&#34; if self.player else &#34;enemy&#34;
    self.ext_name = f&#39;{self.name}({self.affil})&#39;</code></pre>
</details>
</dd>
<dt id="pokete_classes.poke.Poke.set_vars"><code class="name flex">
<span>def <span class="ident">set_vars</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates/sets some vars</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_vars(self):
    &#34;&#34;&#34;Updates/sets some vars&#34;&#34;&#34;
    for name in [&#34;atc&#34;, &#34;defense&#34;, &#34;initiative&#34;]:
        setattr(self, name, round((self.lvl() + self.inf[name]
                + (2 if self.shiny else 0)) * self.nature.get_value(name)))
    for atc in self.attack_obs:
        atc.set_ap(atc.max_ap)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pokete_classes" href="index.html">pokete_classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pokete_classes.poke.upgrade_by_one_lvl" href="#pokete_classes.poke.upgrade_by_one_lvl">upgrade_by_one_lvl</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pokete_classes.poke.Poke" href="#pokete_classes.poke.Poke">Poke</a></code></h4>
<ul class="two-column">
<li><code><a title="pokete_classes.poke.Poke.add_xp" href="#pokete_classes.poke.Poke.add_xp">add_xp</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.attack" href="#pokete_classes.poke.Poke.attack">attack</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.dict" href="#pokete_classes.poke.Poke.dict">dict</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.evolve" href="#pokete_classes.poke.Poke.evolve">evolve</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.from_dict" href="#pokete_classes.poke.Poke.from_dict">from_dict</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.learn_attack" href="#pokete_classes.poke.Poke.learn_attack">learn_attack</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.lvl" href="#pokete_classes.poke.Poke.lvl">lvl</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.set_ap" href="#pokete_classes.poke.Poke.set_ap">set_ap</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.set_player" href="#pokete_classes.poke.Poke.set_player">set_player</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.set_vars" href="#pokete_classes.poke.Poke.set_vars">set_vars</a></code></li>
<li><code><a title="pokete_classes.poke.Poke.wild" href="#pokete_classes.poke.Poke.wild">wild</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>